#coding: utf8
#!/usr/bin/env sage

'''
This is a rough proof-of-concept implementation accompanying
the paper "Rational isogenies from irrational endomorphisms".
ePrint URL: https://ia.cr/2019/1202
'''


# This file was *autogenerated* from the file quat.sage
from sage.all_cmdline import *   # import sage library

_sage_const_419 = Integer(419); _sage_const_12011 = Integer(12011); _sage_const_995337419 = Integer(995337419); _sage_const_1 = Integer(1); _sage_const_1e9 = RealNumber('1e9'); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_40 = Integer(40); _sage_const_1000 = Integer(1000); _sage_const_3 = Integer(3); _sage_const_1e8 = RealNumber('1e8'); _sage_const_2 = Integer(2)
p = _sage_const_419 
p = _sage_const_12011 
p = _sage_const_995337419 

maximal = True

########################################

## find a representation for B_p,∞

q = _sage_const_1 
while True:
    Quat = QuaternionAlgebra(-q,-p, names=('i', 'j', 'k',)); (i, j, k,) = Quat._first_ngens(3)
    if Quat.discriminant() == p: break
    q += _sage_const_1 

########################################

## algorithms

el2vec = lambda a: list(Quat(a))
vec2el = lambda v: sum(x*y for x,y in zip(v, Quat.basis()))

# return a matrix whose row span is the intersection of two matrices' row spans
def intersect(L0, L1):
    return L0.row_module(ZZ).intersection(L1.row_module(ZZ)).basis_matrix()

# find a small "twisting endomorphism" in a given quaternion order
def twistendo(Q):
    M = Q.unit_ideal().basis_matrix()
    L = intersect(M, matrix(map(el2vec, [i,k])))  # compute <i,k> submodule
    S = diagonal_matrix([round(_sage_const_1e9 *sqrt(g.reduced_norm())) for g in Quat.basis()])
    L = (L * S).LLL() * S**-_sage_const_1                      # find small-norm element
    return vec2el(L.rows()[_sage_const_0 ])

# intersect a quaternion O-ideal with O = Q ∩ ℚ(j)
def fpify(I):
    P = matrix(identity_matrix(_sage_const_4 ).rows()[::-_sage_const_1 ])
    M = I.basis_matrix()
    S = matrix(map(list, O.basis())) * matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ]])    # the <1,j> part of O
    L = intersect(M*P, S*P) * P
    ret = [sum(x*g for x,g in zip(r, [_sage_const_1 ,_sage_const_0 ,pi,_sage_const_0 ])) for r in L.rows()]    # convert to K-elements
    return ret[::-_sage_const_1 ] if ret[_sage_const_0 ] not in ZZ else ret

########################################

## generate a test instance

from sage.algebras.quatalg.quaternion_algebra import basis_for_quaternion_lattice
bfql = lambda L: basis_for_quaternion_lattice(L, reverse=True)

#Q0 = Quat.quaternion_order([1, i, (1+j)/2, (i+k)/2])   # y^2 = x^3 - x, only p = 3 mod 4
Q0 = Quat.maximal_order()

K = QuadraticField(-p, names=('pi',)); (pi,) = K._first_ngens(1)
if maximal:
    O = K.maximal_order()
else:
    O = K.order(pi)
    O.fractional_ideal(_sage_const_1 )  # throws NotImplemented as of March 2020

# walk around the isogeny graph to find a "random" maximal order
Q1 = Q0
orig = O.fractional_ideal(_sage_const_1 )
for step in range(_sage_const_40 ):
    while True:
        l = random_prime(_sage_const_1000 , lbound=_sage_const_3 )
        if not Mod(-p,l).is_square(): continue  # check if Elkies
        break
    mu = ZZ(sqrt(Mod(-p,l)))
    orig *= K.fractional_ideal((l, pi-mu))
    # corresponds to quotienting by the mu-eigenspace of Frobenius
    IK = Quat.ideal(bfql(
            Q1.unit_ideal().scale(l).basis()
          + Q1.unit_ideal().scale(j-mu).basis())
        )
    Q1 = IK.right_order()

########################################

## check that the algorithms solve the test instance

from sage.rings.factorint import factor_trial_division
def tryfactor(n):
    if n in ZZ: return factor_trial_division(n, _sage_const_1e8 )
    return tryfactor(n.numerator()) / tryfactor(n.denominator())

if __name__ == '__main__':
    print()
    print('p = {}'.format(p))
    print()

    print('Q₀:')
    for g in Q0.basis():
        print('  {}'.format(g))
    print()

    print('Q₁:')
    for g in Q1.basis():
        print('  {}'.format(g))
    print()

    beta = twistendo(Q0)
    print('\x1b[33mβ = {}\x1b[0m'.format(beta))
    print('norm(β) = {}'.format(tryfactor(beta.reduced_norm())))
    assert beta*j == -j*beta
    print()

    gamma = twistendo(Q1)
    print('\x1b[33mγ = {}\x1b[0m'.format(gamma))
    print('norm(γ) = {}'.format(tryfactor(gamma.reduced_norm())))
    assert gamma*j == -j*gamma
    print

    I = Q0.unit_ideal().scale(beta)
    print('I = Q₀·β:')
    for g in I.basis():
        print('  {}'.format(g))
    print()

    J = Q1.unit_ideal().scale(gamma)
    print('J = Q₁·γ:')
    for g in J.basis():
        print('  {}'.format(g))
    print()

    bb = O.fractional_ideal(fpify(I))
    print('\x1b[36mbb = I ∩ O = <{}>\x1b[0m'.format(bb.gens_two()))
    print('norm(bb) = {}'.format(tryfactor(bb.norm())))
    print('norm(bb)/norm(I) = {}'.format(tryfactor(bb.norm() / I.norm())))
    print()

    cc = O.fractional_ideal(fpify(J))
    print('\x1b[36mcc = J ∩ O = <{}>\x1b[0m'.format(cc.gens_two()))
    print('norm(cc) = {}'.format(tryfactor(cc.norm())))
    print('norm(cc)/norm(J) = {}'.format(tryfactor(cc.norm() / J.norm())))
    print()

    aa2 = bb/cc
    print('--> \x1b[32m[aa]^2 = [bb/cc] = [<{}>]\x1b[0m'.format(aa2.gens_two()))
    print()

    print('actual square of connecting ideal: <{}>'.format((orig**_sage_const_2 ).gens_two()))
    print('equivalent? \x1b[31m{}\x1b[0m'.format((aa2 / orig**_sage_const_2 ).is_principal()))
    print()

